# CASE NLG VERIFIER v0.1.0

"""
The Natural Language Glossary (NLG) is an alphabetical list of types of CASE classes (categories of CASE types).
The functions in this file create CASE objects (instances of such types) while automatically checking ontology and type.
The API (case.py) could be used directly to create non-typed objects if ontology and type checking are not requirements.
However, we advise against this to maintain consistency across community usage of the ontology.

Note that different versions of the NLG exist for different realizations of the Unified Cyber Ontology.
The human legible NLG corresponding to this version of CASE (one realization of UCO) can be found here:
https://casework.github.io/case/case-v0.1.0-natural-language-glossary.html

-----------------------------------------------------
NOTES ON FUNCTION STRUCTURE

    CASE objects:         Search "CREATE A CASE OBJECT" in the API (case.py) to understand the high-level CASE objects.
    Parameters:           All parameters use underscores coming in and are set by default to a Missing object.
    Required parameters:  The CASE Document class is passed in ('_sub' functions also require their superseding CASE class).
    Ontology parameters:  All other parameters are specified by the CASE ontology, and may be required or optional.
    Function docstrings:  'Any number of' = must be a list (otherwise pass in a single Python object)
                          'Exactly one' or 'At least one' = required parameter
                          'At most one' = optional parameter
    Body asserts:         1) superseding CASE class/type (if applicable)
                          2) required parameters
                          3) optional parameters 
    Return:               The desired object is instantiated and parameters converted to CamelCase for JSON-LD output.

    See examples/NLG_template.txt for a list of all instances of function definitions, docstrings, and assert statements found in the NLG.

-----------------------------------------------------
ORGANIZATION FOR DEVELOPERS

As development of the ontology moves forward new functions and API classes may be added.
If you wish to contribute to improvement, follow these note-taking standards to help us stay on the same proverbial page.
    - #TODO:NothingElseToCheck - If no parameters are checked (incomplete ontology or ambiguity).
    - #NOCHECK:<param_name>    - If a parameter does not have a check (but at least one other parameter does).
    - #TODO:<type_name>        - If a standard has not been defined yet for a type check (e.g. #TODO:URI).
                                 Custom functions for such types may be found in the last section of this file.
    - There are two 'Identity' NLG types, one a 'core_' and one a 'propbundle_'.
      In assert output state which is required via "of type Identity (core)" or "of type Identity (propbundle)".
"""


import case
import sys
import unittest
import datetime.datetime
from xsd_validation import XSDValidator

autogenerated_xsd = "xsd_prop_types.xsd"

class Missing(object):
    def __init__(self):
        self.is_missing = True


#=====================================================
#-- CORE

def core_Action(case_doc, actionStatus=Missing(), environment=Missing(), error=Missing(), subAction=Missing()):
	'''
	:param actionStatus: Any number of type ActionStatus.
	:param environment: Any number of type UcoObject.
	:param error: Any number of type UcoObject.
	:param subAction: Any number of type Action.
	:return: A CoreCategory object.
	'''



	if not isinstance(actionStatus, Missing):
		assert isinstance(actionStatus, list),\
		"[core_Action] actionStatus must be of type List of ActionStatus."
		assert all(isinstance(i, case.DuckCategory)) and (i.type=="ActionStatus") for i in actionStatus),\
		"[core_Action] actionStatus must be of type List of ActionStatus."
	else:
		miss_prop_list.append(actionStatus)

	if not isinstance(environment, Missing):
		assert isinstance(environment, list),\
		"[core_Action] environment must be of type List of UcoObject."
		assert XSDValidator.validateXSD(environment, "UcoObject", autogenerated_xsd),\
		"[core_Action] environment must be of type List of UcoObject."
	else:
		miss_prop_list.append(environment)

	if not isinstance(error, Missing):
		assert isinstance(error, list),\
		"[core_Action] error must be of type List of UcoObject."
		assert XSDValidator.validateXSD(error, "UcoObject", autogenerated_xsd),\
		"[core_Action] error must be of type List of UcoObject."
	else:
		miss_prop_list.append(error)

	if not isinstance(subAction, Missing):
		assert isinstance(subAction, list),\
		"[core_Action] subAction must be of type List of Action."
		assert all(isinstance(i, case.CoreCategory)) and (i.type=="Action") for i in subAction),\
		"[core_Action] subAction must be of type List of Action."
	else:
		miss_prop_list.append(subAction)

	return case_doc.create_CoreCategory('Action', actionStatus=actionStatus, environment=environment, error=error, subAction=subAction)

def core_Assertion(case_doc):
	'''
	:return: A CoreCategory object.
	'''



	return case_doc.create_CoreCategory('Assertion')

def core_Bundle(case_doc):
	'''
	:return: A CoreCategory object.
	'''



	return case_doc.create_CoreCategory('Bundle')

def core_Identity(case_doc):
	'''
	:return: A CoreCategory object.
	'''



	return case_doc.create_CoreCategory('Identity')

def core_Investigation(case_doc, endAction=Missing(), forensicActions=Missing(), investigator=Missing(), startAction=Missing(), suspectedOffense=Missing(), victim=Missing()):
	'''
	:param endAction: Any number of type Action.
	:param forensicActions: Any number of type OrderedList.
	:param startAction: Any number of type Action.
	:param suspectedOffense: Any number of type string.
	:return: A CoreCategory object.
	'''



	if not isinstance(endAction, Missing):
		assert isinstance(endAction, list),\
		"[core_Investigation] endAction must be of type List of Action."
		assert all(isinstance(i, case.CoreCategory)) and (i.type=="Action") for i in endAction),\
		"[core_Investigation] endAction must be of type List of Action."
	else:
		miss_prop_list.append(endAction)

	if not isinstance(forensicActions, Missing):
		assert isinstance(forensicActions, list),\
		"[core_Investigation] forensicActions must be of type List of OrderedList."
		assert all(isinstance(i, case.DuckCategory)) and (i.type=="OrderedList") for i in forensicActions),\
		"[core_Investigation] forensicActions must be of type List of OrderedList."
	else:
		miss_prop_list.append(forensicActions)

	if not isinstance(startAction, Missing):
		assert isinstance(startAction, list),\
		"[core_Investigation] startAction must be of type List of Action."
		assert all(isinstance(i, case.CoreCategory)) and (i.type=="Action") for i in startAction),\
		"[core_Investigation] startAction must be of type List of Action."
	else:
		miss_prop_list.append(startAction)

	if not isinstance(suspectedOffense, Missing):
		assert isinstance(suspectedOffense, list),\
		"[core_Investigation] suspectedOffense must be of type List of string."
		assert XSDValidator.validateXSD(suspectedOffense, "string", autogenerated_xsd),\
		"[core_Investigation] suspectedOffense must be of type List of string."
	else:
		miss_prop_list.append(suspectedOffense)

	return case_doc.create_CoreCategory('Investigation', endAction=endAction, forensicActions=forensicActions, investigator=investigator, startAction=startAction, suspectedOffense=suspectedOffense, victim=victim)

def core_Location(case_doc):
	'''
	:return: A CoreCategory object.
	'''



	return case_doc.create_CoreCategory('Location')

def core_ProvenanceRecord(case_doc, exhibitNumber=Missing()):
	'''
	:param exhibitNumber: Any number of type string.
	:return: A CoreCategory object.
	'''



	if not isinstance(exhibitNumber, Missing):
		assert isinstance(exhibitNumber, list),\
		"[core_ProvenanceRecord] exhibitNumber must be of type List of string."
		assert XSDValidator.validateXSD(exhibitNumber, "string", autogenerated_xsd),\
		"[core_ProvenanceRecord] exhibitNumber must be of type List of string."
	else:
		miss_prop_list.append(exhibitNumber)

	return case_doc.create_CoreCategory('ProvenanceRecord', exhibitNumber=exhibitNumber)

def core_Relationship(case_doc, bidirectional=Missing(), kindOfRelationship=Missing(), target=Missing()):
	'''
	:param bidirectional: Any number of type boolean.
	:param kindOfRelationship: Any number of type string.
	:param target: Any number of type UcoObject.
	:return: A CoreCategory object.
	'''



	if not isinstance(bidirectional, Missing):
		assert isinstance(bidirectional, list),\
		"[core_Relationship] bidirectional must be of type List of boolean."
		assert XSDValidator.validateXSD(bidirectional, "boolean", autogenerated_xsd),\
		"[core_Relationship] bidirectional must be of type List of boolean."
	else:
		miss_prop_list.append(bidirectional)

	if not isinstance(kindOfRelationship, Missing):
		assert isinstance(kindOfRelationship, list),\
		"[core_Relationship] kindOfRelationship must be of type List of string."
		assert XSDValidator.validateXSD(kindOfRelationship, "string", autogenerated_xsd),\
		"[core_Relationship] kindOfRelationship must be of type List of string."
	else:
		miss_prop_list.append(kindOfRelationship)

	if not isinstance(target, Missing):
		assert isinstance(target, list),\
		"[core_Relationship] target must be of type List of UcoObject."
		assert XSDValidator.validateXSD(target, "UcoObject", autogenerated_xsd),\
		"[core_Relationship] target must be of type List of UcoObject."
	else:
		miss_prop_list.append(target)

	return case_doc.create_CoreCategory('Relationship', bidirectional=bidirectional, kindOfRelationship=kindOfRelationship, target=target)

def core_Role(case_doc):
	'''
	:return: A CoreCategory object.
	'''



	return case_doc.create_CoreCategory('Role')

def core_Tool(case_doc, toolType=Missing(), vendor=Missing()):
	'''
	:param toolType: Any number of type string.
	:param vendor: Any number of type string.
	:return: A CoreCategory object.
	'''



	if not isinstance(toolType, Missing):
		assert isinstance(toolType, list),\
		"[core_Tool] toolType must be of type List of string."
		assert XSDValidator.validateXSD(toolType, "string", autogenerated_xsd),\
		"[core_Tool] toolType must be of type List of string."
	else:
		miss_prop_list.append(toolType)

	if not isinstance(vendor, Missing):
		assert isinstance(vendor, list),\
		"[core_Tool] vendor must be of type List of string."
		assert XSDValidator.validateXSD(vendor, "string", autogenerated_xsd),\
		"[core_Tool] vendor must be of type List of string."
	else:
		miss_prop_list.append(vendor)

	return case_doc.create_CoreCategory('Tool', toolType=toolType, vendor=vendor)

def core_Trace(case_doc):
	'''
	:return: A CoreCategory object.
	'''



	return case_doc.create_CoreCategory('Trace')



#=====================================================
#-- CORE SUB

def core_sub_Annotation(case_doc, parent_object, tag=Missing()):
	'''
	:param tag: Any number of type string.
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='Assertion')),\
	"[core_sub_Annotation] parent_object must be of type Assertion."



	if not isinstance(tag, Missing):
		assert isinstance(tag, list),\
		"[core_sub_Annotation] tag must be of type List of string."
		assert XSDValidator.validateXSD(tag, "string", autogenerated_xsd),\
		"[core_sub_Annotation] tag must be of type List of string."
	else:
		miss_prop_list.append(tag)

	return case_doc.create_SubCategory('Annotation', tag=tag)

def core_sub_BenevolentRole(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='Role')),\
	"[core_sub_BenevolentRole] parent_object must be of type Role."



	return case_doc.create_SubCategory('BenevolentRole')

def core_sub_ForensicAction(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='Action')),\
	"[core_sub_ForensicAction] parent_object must be of type Action."



	return case_doc.create_SubCategory('ForensicAction')

def core_sub_MaliciousRole(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='Role')),\
	"[core_sub_MaliciousRole] parent_object must be of type Role."



	return case_doc.create_SubCategory('MaliciousRole')

def core_sub_NeutralRole(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='Role')),\
	"[core_sub_NeutralRole] parent_object must be of type Role."



	return case_doc.create_SubCategory('NeutralRole')



#=====================================================
#-- CORE SUB SUB

def core_sub_sub_Attorney(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='BenevolentRole')),\
	"[core_sub_sub_Attorney] parent_object must be of type BenevolentRole."



	return case_doc.create_SubCategory('Attorney')

def core_sub_sub_Examiner(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='BenevolentRole')),\
	"[core_sub_sub_Examiner] parent_object must be of type BenevolentRole."



	return case_doc.create_SubCategory('Examiner')

def core_sub_sub_Investigator(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='BenevolentRole')),\
	"[core_sub_sub_Investigator] parent_object must be of type BenevolentRole."



	return case_doc.create_SubCategory('Investigator')

def core_sub_sub_Subject(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='MaliciousRole')),\
	"[core_sub_sub_Subject] parent_object must be of type MaliciousRole."



	return case_doc.create_SubCategory('Subject')

def core_sub_sub_Victim(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.CoreCategory) and parent_object.type=='NeutralRole')),\
	"[core_sub_sub_Victim] parent_object must be of type NeutralRole."



	return case_doc.create_SubCategory('Victim')



#=====================================================
#-- DUCK

def duck_Enumeration(case_doc):
	'''
	:return: A DuckCategory object.
	'''



	return case_doc.create_DuckCategory('Enumeration')

def duck_OrderedList(case_doc):
	'''
	:return: A DuckCategory object.
	'''



	return case_doc.create_DuckCategory('OrderedList')

def duck_PropertyBundle(case_doc):
	'''
	:return: A DuckCategory object.
	'''



	return case_doc.create_DuckCategory('PropertyBundle')

def duck_Slot(case_doc):
	'''
	:return: A DuckCategory object.
	'''



	return case_doc.create_DuckCategory('Slot')

def duck_SupportingClasses(case_doc):
	'''
	:return: A DuckCategory object.
	'''



	return case_doc.create_DuckCategory('SupportingClasses')

def duck_UcoObject(case_doc, createdBy=Missing(), propertyBundle=Missing(), specVersion=Missing(), type=Missing()):
	'''
	:param createdBy: Any number of type Identity.
	:param propertyBundle: Any number of type PropertyBundle.
	:param specVersion: Any number of type string.
	:param type: Any number of type string.
	:return: A DuckCategory object.
	'''



	if not isinstance(createdBy, Missing):
		assert isinstance(createdBy, list),\
		"[duck_UcoObject] createdBy must be of type List of Identity."
		assert all(isinstance(i, case.CoreCategory)) and (i.type=="Identity") for i in createdBy),\
		"[duck_UcoObject] createdBy must be of type List of Identity."
	else:
		miss_prop_list.append(createdBy)

	if not isinstance(propertyBundle, Missing):
		assert isinstance(propertyBundle, list),\
		"[duck_UcoObject] propertyBundle must be of type List of PropertyBundle."
		assert all(isinstance(i, case.DuckCategory)) and (i.type=="PropertyBundle") for i in propertyBundle),\
		"[duck_UcoObject] propertyBundle must be of type List of PropertyBundle."
	else:
		miss_prop_list.append(propertyBundle)

	if not isinstance(specVersion, Missing):
		assert isinstance(specVersion, list),\
		"[duck_UcoObject] specVersion must be of type List of string."
		assert XSDValidator.validateXSD(specVersion, "string", autogenerated_xsd),\
		"[duck_UcoObject] specVersion must be of type List of string."
	else:
		miss_prop_list.append(specVersion)

	if not isinstance(type, Missing):
		assert isinstance(type, list),\
		"[duck_UcoObject] type must be of type List of string."
		assert XSDValidator.validateXSD(type, "string", autogenerated_xsd),\
		"[duck_UcoObject] type must be of type List of string."
	else:
		miss_prop_list.append(type)

	return case_doc.create_DuckCategory('UcoObject', createdBy=createdBy, propertyBundle=propertyBundle, specVersion=specVersion, type=type)



#=====================================================
#-- DUCK SUB

def duck_sub_AccountType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_AccountType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('AccountType')

def duck_sub_ActionStatus(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_ActionStatus] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('ActionStatus')

def duck_sub_ArrayOfAction(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='OrderedList')),\
	"[duck_sub_ArrayOfAction] parent_object must be of type OrderedList."



	return case_doc.create_SubCategory('ArrayOfAction')

def duck_sub_ArrayOfHash(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='OrderedList')),\
	"[duck_sub_ArrayOfHash] parent_object must be of type OrderedList."



	return case_doc.create_SubCategory('ArrayOfHash')

def duck_sub_ArrayOfObject(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='OrderedList')),\
	"[duck_sub_ArrayOfObject] parent_object must be of type OrderedList."



	return case_doc.create_SubCategory('ArrayOfObject')

def duck_sub_ArrayOfString(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='OrderedList')),\
	"[duck_sub_ArrayOfString] parent_object must be of type OrderedList."



	return case_doc.create_SubCategory('ArrayOfString')

def duck_sub_AuthorizationType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_AuthorizationType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('AuthorizationType')

def duck_sub_ByteOrder(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_ByteOrder] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('ByteOrder')

def duck_sub_CompressionMethod(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_CompressionMethod] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('CompressionMethod')

def duck_sub_ConfigurationSetting(case_doc, parent_object, itemDescription=Missing(), itemName=Missing(), itemType=Missing(), itemValue=Missing()):
	'''
	:param itemDescription: Any number of type string.
	:param itemName: Any number of type string.
	:param itemType: Any number of type string.
	:param itemValue: Any number of type string.
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_ConfigurationSetting] parent_object must be of type SupportingClasses."



	if not isinstance(itemDescription, Missing):
		assert isinstance(itemDescription, list),\
		"[duck_sub_ConfigurationSetting] itemDescription must be of type List of string."
		assert XSDValidator.validateXSD(itemDescription, "string", autogenerated_xsd),\
		"[duck_sub_ConfigurationSetting] itemDescription must be of type List of string."
	else:
		miss_prop_list.append(itemDescription)

	if not isinstance(itemName, Missing):
		assert isinstance(itemName, list),\
		"[duck_sub_ConfigurationSetting] itemName must be of type List of string."
		assert XSDValidator.validateXSD(itemName, "string", autogenerated_xsd),\
		"[duck_sub_ConfigurationSetting] itemName must be of type List of string."
	else:
		miss_prop_list.append(itemName)

	if not isinstance(itemType, Missing):
		assert isinstance(itemType, list),\
		"[duck_sub_ConfigurationSetting] itemType must be of type List of string."
		assert XSDValidator.validateXSD(itemType, "string", autogenerated_xsd),\
		"[duck_sub_ConfigurationSetting] itemType must be of type List of string."
	else:
		miss_prop_list.append(itemType)

	if not isinstance(itemValue, Missing):
		assert isinstance(itemValue, list),\
		"[duck_sub_ConfigurationSetting] itemValue must be of type List of string."
		assert XSDValidator.validateXSD(itemValue, "string", autogenerated_xsd),\
		"[duck_sub_ConfigurationSetting] itemValue must be of type List of string."
	else:
		miss_prop_list.append(itemValue)

	return case_doc.create_SubCategory('ConfigurationSetting', itemDescription=itemDescription, itemName=itemName, itemType=itemType, itemValue=itemValue)

def duck_sub_DataType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_DataType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('DataType')

def duck_sub_DeviceType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_DeviceType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('DeviceType')

def duck_sub_DictionaryItem(case_doc, parent_object, key=Missing()):
	'''
	:param key: Any number of type string.
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_DictionaryItem] parent_object must be of type SupportingClasses."



	if not isinstance(key, Missing):
		assert isinstance(key, list),\
		"[duck_sub_DictionaryItem] key must be of type List of string."
		assert XSDValidator.validateXSD(key, "string", autogenerated_xsd),\
		"[duck_sub_DictionaryItem] key must be of type List of string."
	else:
		miss_prop_list.append(key)

	return case_doc.create_SubCategory('DictionaryItem', key=key)

def duck_sub_DiskPartitionType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_DiskPartitionType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('DiskPartitionType')

def duck_sub_DiskType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_DiskType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('DiskType')

def duck_sub_DomainName(case_doc, parent_object, isTLD=Missing()):
	'''
	:param isTLD: Any number of type boolean.
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_DomainName] parent_object must be of type SupportingClasses."



	if not isinstance(isTLD, Missing):
		assert isinstance(isTLD, list),\
		"[duck_sub_DomainName] isTLD must be of type List of boolean."
		assert XSDValidator.validateXSD(isTLD, "boolean", autogenerated_xsd),\
		"[duck_sub_DomainName] isTLD must be of type List of boolean."
	else:
		miss_prop_list.append(isTLD)

	return case_doc.create_SubCategory('DomainName', isTLD=isTLD)

def duck_sub_EmailAddress(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_EmailAddress] parent_object must be of type SupportingClasses."



	return case_doc.create_SubCategory('EmailAddress')

def duck_sub_EncodingMethod(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_EncodingMethod] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('EncodingMethod')

def duck_sub_EncryptionMethod(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_EncryptionMethod] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('EncryptionMethod')

def duck_sub_EncryptionMode(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_EncryptionMode] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('EncryptionMode')

def duck_sub_ErrorType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_ErrorType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('ErrorType')

def duck_sub_FileMismatchType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_FileMismatchType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('FileMismatchType')

def duck_sub_FilePath(case_doc, parent_object, delimiter=Missing(), filePathSegments=Missing()):
	'''
	:param delimiter: Any number of type string.
	:param filePathSegments: Any number of type OrderedList.
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_FilePath] parent_object must be of type SupportingClasses."



	if not isinstance(delimiter, Missing):
		assert isinstance(delimiter, list),\
		"[duck_sub_FilePath] delimiter must be of type List of string."
		assert XSDValidator.validateXSD(delimiter, "string", autogenerated_xsd),\
		"[duck_sub_FilePath] delimiter must be of type List of string."
	else:
		miss_prop_list.append(delimiter)

	if not isinstance(filePathSegments, Missing):
		assert isinstance(filePathSegments, list),\
		"[duck_sub_FilePath] filePathSegments must be of type List of OrderedList."
		assert all(isinstance(i, case.DuckCategory)) and (i.type=="OrderedList") for i in filePathSegments),\
		"[duck_sub_FilePath] filePathSegments must be of type List of OrderedList."
	else:
		miss_prop_list.append(filePathSegments)

	return case_doc.create_SubCategory('FilePath', delimiter=delimiter, filePathSegments=filePathSegments)

def duck_sub_FileSystemType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_FileSystemType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('FileSystemType')

def duck_sub_GlobalFlagType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_GlobalFlagType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('GlobalFlagType')

def duck_sub_HashMethod(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_HashMethod] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('HashMethod')

def duck_sub_IPv4Address(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_IPv4Address] parent_object must be of type SupportingClasses."



	return case_doc.create_SubCategory('IPv4Address')

def duck_sub_IPv6Address(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_IPv6Address] parent_object must be of type SupportingClasses."



	return case_doc.create_SubCategory('IPv6Address')

def duck_sub_ImageCompressionMethod(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_ImageCompressionMethod] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('ImageCompressionMethod')

def duck_sub_ImageType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_ImageType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('ImageType')

def duck_sub_Language(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_Language] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('Language')

def duck_sub_MACAddress(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_MACAddress] parent_object must be of type SupportingClasses."



	return case_doc.create_SubCategory('MACAddress')

def duck_sub_MimePartType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_MimePartType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('MimePartType')

def duck_sub_MimeType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_MimeType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('MimeType')

def duck_sub_PEType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_PEType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('PEType')

def duck_sub_PasswordType(case_doc, parent_object):
	'''
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='Enumeration')),\
	"[duck_sub_PasswordType] parent_object must be of type Enumeration."



	return case_doc.create_SubCategory('PasswordType')

def duck_sub_ReceivedEvent(case_doc, parent_object, receivedTime=Missing(), receiver=Missing()):
	'''
	:param receivedTime: Any number of type dateTimeStamp.
	:param receiver: Any number of type Trace.
	:return: A SubCategory object.
	'''

	assert (isinstance(parent_object, case.DuckCategory) and parent_object.type=='SupportingClasses')),\
	"[duck_sub_ReceivedEvent] parent_object must be of type SupportingClasses."



	if not isinstance(receivedTime, Missing):
		assert isinstance(receivedTime, list),\
		"[duck_sub_ReceivedEvent] receivedTime must be of type List of dateTimeStamp."
		assert XSDValidator.validateXSD(receivedTime, "dateTimeStamp", autogenerated_xsd),\
		"[duck_sub_ReceivedEvent] receivedTime must be of type List of dateTimeStamp."
